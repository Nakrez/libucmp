#ifndef UCMP_LINK_ELF_IMPORTER_HXX
# define UCMP_LINK_ELF_IMPORTER_HXX

# include <ucmp/link/elf/elf-importer.hh>

namespace ucmp
{
    namespace link
    {
        template <LinkContext::Class Elf>
        File*
        ElfImporter::ElfInnerImporter<Elf>::parse_file(misc::MemoryBuffer& buf)
        {
            File* f = nullptr;

            const Ehdr *header;

            header = reinterpret_cast<const Ehdr*> (buf.buffer_get());

            if (header->e_type == ELF::ET_DYN)
                f = new File(File::DynLib);
            else
                f = new File(File::Object);

            locate_shstr(buf, header);

            const Shdr *section;

            section = reinterpret_cast<const Shdr*> (buf.buffer_get() +
                                                     header->e_shoff);

            for (int i = 0; i < header->e_shnum; ++i, ++section)
            {
                // Don't import shstrtab, it's useless
                if (i == header->e_shstrndx)
                    continue;

                parse_section(f, buf, section);
            }

            return f;
        }

        template <LinkContext::Class Elf>
        void
        ElfImporter::ElfInnerImporter<Elf>::parse_section(File* f,
                                                          misc::MemoryBuffer& buf,
                                                          const Shdr* section)
        {
            // Don't import null section, useless because it will be
            // regenerated by writer
            if (section->sh_type == ELF::SHT_NULL)
                return;

            std::cout << shname_get(section->sh_name) << std::endl;
        }

        template <LinkContext::Class Elf>
        void
        ElfImporter::ElfInnerImporter<Elf>::locate_shstr(misc::MemoryBuffer& buf,
                                                         const Ehdr* elf)
        {
            const Shdr *shstr_section;

            shstr_section = reinterpret_cast<const Shdr*> (buf.buffer_get() +
                                                           elf->e_shoff +
                                                           elf->e_shstrndx *
                                                           sizeof (Shdr));

            shstrtab_ = buf.buffer_get() + shstr_section->sh_offset;
        }

        template <LinkContext::Class Elf>
        std::string ElfImporter::ElfInnerImporter<Elf>::shname_get(int index)
        {
            return std::string(shstrtab_ + index);
        }
    } // namespace link
} // namespace ucmp

#endif /* !UCMP_LINK_ELF_IMPORTER_HXX */
